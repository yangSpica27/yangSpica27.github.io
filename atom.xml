<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yangspica27.github.io/</id>
    <title>Spica 27&apos;S Room</title>
    <updated>2020-02-10T00:20:00.149Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yangspica27.github.io/"/>
    <link rel="self" href="https://yangspica27.github.io/atom.xml"/>
    <subtitle>玻璃晴朗 橘子辉煌</subtitle>
    <logo>https://yangspica27.github.io/images/avatar.png</logo>
    <icon>https://yangspica27.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Spica 27&apos;S Room</rights>
    <entry>
        <title type="html"><![CDATA[如何绘制一个MD风格的输入框]]></title>
        <id>https://yangspica27.github.io/post/ru-he-hui-zhi-yi-ge-md-feng-ge-de-shu-ru-kuang</id>
        <link href="https://yangspica27.github.io/post/ru-he-hui-zhi-yi-ge-md-feng-ge-de-shu-ru-kuang">
        </link>
        <updated>2020-02-09T13:18:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yangspica27.github.io//post-images/1581254342503.gif" alt="" loading="lazy"></figure>
<h2 id="提要">提要</h2>
<p>首先我们分析效果图 达成的效果 输入框有数值的时候，绘制hint的文字在顶部，当输入框没有数值的时候将绘制的文字去掉，并且过程中插入一个向下/向上的一个移动动画。</p>
<h2 id="准备工作">准备工作</h2>
<p>首先定义需要的量</p>
<pre><code class="language-java">public static final float TEXT_SIZE = Utils.dpTopx(12);//绘制的hint的文字大小
public static final float TEXT_MARGIN = Utils.dpTopx(8);//绘制的hint文本的缩进距离
public static final int TEXT_VERTICAL_OFFSET = (int) Utils.dpTopx(22);//绘制的hint文字水平偏移
public static final int TEXT_HORIZONTAL_OFFSET = (int) Utils.dpTopx(5);//绘制的hint文字垂直方向偏移
public static final int TEXT_ANIMATION_OFFSET = (int) Utils.dpTopx(16);//动画的移动幅度
boolean floatingLableShow;//当前状态：是否显示上部的hint文字

Rect boundPading;//用于获取pading
float floatingLableFraction = 0;//动画执行的进度
private boolean useFloatingLabel = true;//是否使用MD效果
ObjectAnimator animator;//动画对象
Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);//绘制文字的画笔
</code></pre>
<h2 id="初始化">初始化</h2>
<pre><code class="language-java">{
      paint.setTextSize(TEXT_SIZE);
}
public MaterialEditText(Context context, AttributeSet attrs) {
    super(context, attrs);
    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MaterialEditText);
    useFloatingLabel = typedArray.getBoolean(R.styleable.MaterialEditText_useFloatingLabel, true);//获取attr中声明的值，如果不需要在xml中设置属性，可以跳过此步骤
    typedArray.recycle(); // 回收
  }
</code></pre>
<h2 id="hint文字的绘制">Hint文字的绘制</h2>
<pre><code class="language-java">  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    paint.setAlpha((int) (0xff * floatingLableFraction));//根据动画执行的进度设置画笔的透明度
    float extraOffset = TEXT_ANIMATION_OFFSET * (1 - floatingLableFraction);//根据动画的执行进度获取水平方向上的偏移量

    if (useFloatingLabel) {
      canvas.drawText(
          (String) getHint(), TEXT_HORIZONTAL_OFFSET, TEXT_VERTICAL_OFFSET + extraOffset, paint);//绘制文字，绘制时候根据动画进度可以变化水平位置
    }
  }
</code></pre>
<h2 id="动画">动画</h2>
<pre><code class="language-java">private ObjectAnimator getAninator() {
    if (animator == null) {
      animator = ObjectAnimator.ofFloat(MaterialEditText.this, &quot;floatingLableFraction&quot;, 0, 1);
    }
    return animator;
  }
</code></pre>
<h2 id="布局重新测量">布局重新测量</h2>
<pre><code class="language-java">private void onUseFloatLableChanged() {

    if (useFloatingLabel) {
      setPadding(
          getPaddingLeft(),
          (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),
          getPaddingRight(),
          getPaddingBottom());

    } else {
      setPadding(getPaddingLeft(), (boundPading.top), getPaddingRight(), getPaddingBottom());
    }
  }
</code></pre>
<pre><code class="language-java">  public void setUseFloatingLabel(boolean useFloatingLabel) {

    if (this.useFloatingLabel != useFloatingLabel) {
      this.useFloatingLabel = useFloatingLabel;
      onUseFloatLableChanged();
    }
    requestLayout(); // 重新测量
  }
</code></pre>
<h2 id="设置监听器">设置监听器</h2>
<pre><code class="language-java"> addTextChangedListener(
        new TextWatcher() {
          @Override
          public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

          @Override
          public void onTextChanged(CharSequence s, int start, int before, int count) {

            if (useFloatingLabel) {

              if (floatingLableShow &amp;&amp; TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().reverse();

              } else if (!floatingLableShow &amp;&amp; !TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().start();
              }
            }
          }

          @Override
          public void afterTextChanged(Editable s) {}
        });
</code></pre>
<h1 id="tips">Tips</h1>
<ul>
<li>
<p>为什么获取paddingTop使用<code>boundPading.top</code>而不会使用<code>getPaddingTop</code>?<br>
因为此View中，Padding并不是一个定值，每次<code>setPadding</code>的时候，都会进行改变,所以要将Padding恢复的时候，要涉及到一个累减的一个问题，而从background中获取的bounds是一个定值，所以可以有效避免复杂的计算。</p>
</li>
<li>
<p><code>getAninator().start();</code>和<code>getAninator().reverse();</code>啥玩意还能这样子操作？？？<br>
使用<code>getAninator()</code>可以避免重复构造动画对象避免性能损失，start表示的是动画的正方向执行，reverse表示倒叙执行</p>
</li>
</ul>
<h3 id="完整代码">完整代码</h3>
<pre><code class="language-java">public class MaterialEditText extends AppCompatEditText {
  private static final String TAG = &quot;MaterialEditText&quot;;

  public static final float TEXT_SIZE = Utils.dpTopx(12);

  public static final float TEXT_MARGIN = Utils.dpTopx(8);
  public static final int TEXT_VERTICAL_OFFSET = (int) Utils.dpTopx(22);
  public static final int TEXT_HORIZONTAL_OFFSET = (int) Utils.dpTopx(5);
  public static final int TEXT_ANIMATION_OFFSET = (int) Utils.dpTopx(16);

  Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);

  boolean floatingLableShow;

  ObjectAnimator animator;

  Rect boundPading;
  float floatingLableFraction = 0;
  private boolean useFloatingLabel = true;

  {
    paint.setTextSize(TEXT_SIZE);
    boundPading = getBackground().getBounds();

    setPadding(
        getPaddingLeft(),
        (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),
        getPaddingRight(),
        getPaddingBottom());

    addTextChangedListener(
        new TextWatcher() {
          @Override
          public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

          @Override
          public void onTextChanged(CharSequence s, int start, int before, int count) {

            if (useFloatingLabel) {

              if (floatingLableShow &amp;&amp; TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().reverse();

              } else if (!floatingLableShow &amp;&amp; !TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().start();
              }
            }
          }

          @Override
          public void afterTextChanged(Editable s) {}
        });
  }

  public MaterialEditText(Context context, AttributeSet attrs) {
    super(context, attrs);
    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MaterialEditText);
    useFloatingLabel = typedArray.getBoolean(R.styleable.MaterialEditText_useFloatingLabel, true);
    typedArray.recycle(); // 回收
  }

  public float getFloatingLableFraction() {
    return floatingLableFraction;
  }

  public void setFloatingLableFraction(float floatingLableFraction) {
    this.floatingLableFraction = floatingLableFraction;
    invalidate();
  }

  private void onUseFloatLableChanged() {

    if (useFloatingLabel) {
      setPadding(
          getPaddingLeft(),
          (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),
          getPaddingRight(),
          getPaddingBottom());

    } else {
      setPadding(getPaddingLeft(), (boundPading.top), getPaddingRight(), getPaddingBottom());
    }
  }

  public void setUseFloatingLabel(boolean useFloatingLabel) {

    if (this.useFloatingLabel != useFloatingLabel) {
      this.useFloatingLabel = useFloatingLabel;
      onUseFloatLableChanged();
    }
    requestLayout(); // 重新测量
  }

  private ObjectAnimator getAninator() {
    if (animator == null) {
      animator = ObjectAnimator.ofFloat(MaterialEditText.this, &quot;floatingLableFraction&quot;, 0, 1);
    }
    return animator;
  }

  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    paint.setAlpha((int) (0xff * floatingLableFraction));
    float extraOffset = TEXT_ANIMATION_OFFSET * (1 - floatingLableFraction);

    if (useFloatingLabel) {
      canvas.drawText(
          (String) getHint(), TEXT_HORIZONTAL_OFFSET, TEXT_VERTICAL_OFFSET + extraOffset, paint);
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随想]]></title>
        <id>https://yangspica27.github.io/post/sui-xiang</id>
        <link href="https://yangspica27.github.io/post/sui-xiang">
        </link>
        <updated>2020-02-09T01:36:49.000Z</updated>
        <content type="html"><![CDATA[<p>作为程序员，如果一个问题出现第二次，就是不能容忍的，但生活中，每个人都难以避免地不断重新犯错，过去的我总觉得给别人三次机会就不能再多了，这很多时候导致了我的不开心，直到我发觉这个事情，并不是每个人都是程序员，特别是家人，很多事情的宽容次数，三次不够，设为十次也不应该，如果可以，应该尽可能无限次宽容，因为他们也总是无限次宽容你，推广开来，就算是对外人也应该如此，宽容没有限数，不要再有后悔莫及的事情了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[技能大赛训练知识小点]]></title>
        <id>https://yangspica27.github.io/post/Competition_notes</id>
        <link href="https://yangspica27.github.io/post/Competition_notes">
        </link>
        <updated>2020-02-09T01:03:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断网络状态">判断网络状态</h2>
<pre><code class="language-java">private boolean testIntent() {
  ConnectivityManager mConnectivityManagerr =
      (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo mNetworkInfo = mConnectivityManagerr.getActiveNetworkInfo();
  if (mNetworkInfo != null) {
    return mNetworkInfo.isAvailable();
  }
  return false;
}
</code></pre>
<h2 id="地图初始化">地图初始化</h2>
<pre><code class="language-java">//地图的初始化：
@Override
protected void onDestroy() {
  super.onDestroy();
  mMapView.onDestroy();
}
@Override
protected void onResume() {
  super.onResume();
  mMapView.onResume();
}
@Override
protected void onPause() {
  super.onPause();
  mMapView.onPause();
}
@Override
protected void onSaveInstanceState(Bundle outState) {
  super.onSaveInstanceState(outState);
  mMapView.onSaveInstanceState(outState);
}
</code></pre>
<h2 id="地图切换图层">地图切换图层</h2>
<pre><code class="language-java">aMap.setMapType(AMap.MAP_TYPE_SATELLITE);
</code></pre>
<h2 id="地图添加点">地图添加点</h2>
<pre><code class="language-java">aMap.addMarker(new MarkerOptions().position(latLngs).title(&quot;小车位置&quot;));
</code></pre>
<h2 id="通知的创建">通知的创建</h2>
<pre><code class="language-java">NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
  NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
builder.setSmallIcon(R.mipmap.icon101);//必须
builder.setContentTitle(“……”);
mNotifyMgr.notify(1, builder.build());
</code></pre>
<h2 id="viewpager预加载">viewPager预加载</h2>
<pre><code class="language-java">viewPager.setOffscreenPageLimit();
</code></pre>
<h2 id="textview跑马灯">TextView跑马灯</h2>
<pre><code class="language-XML">&lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:ellipsize=&quot;marquee&quot;
            android:marqueeRepeatLimit=&quot;marquee_forever&quot; /&gt;
</code></pre>
<pre><code class="language-java">textView.setSelected(true);
</code></pre>
<h2 id="greendao初始化">GreenDao初始化</h2>
<pre><code class="language-java">greendao {
     schemaVersion 1
     daoPackage 'com.lenovo.smarttraffic.db'
     targetGenDir 'src/main/java'
}
    /**
     * 初始化GreenDao,直接在Application中进行初始化操作
     */
    private void initGreenDao() {
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;jiaotong.db&quot;);
        SQLiteDatabase db = helper.getWritableDatabase();
        DaoMaster daoMaster = new DaoMaster(db);
        daoSession = daoMaster.newSession();
    }

    private DaoSession daoSession;
    public DaoSession getDaoSession() {
        return daoSession;
    }
</code></pre>
<h2 id="dp2px无需上下文">dp2px（无需上下文）</h2>
<pre><code class="language-java">public static float dpTopx(int dp) {

  return TypedValue.applyDimension(
      TypedValue.COMPLEX_UNIT_DIP, dp, Resources.getSystem().getDisplayMetrics());
}
</code></pre>
<h2 id="饼图拉线">饼图拉线</h2>
<pre><code class="language-java">dataSet.setValueLinePart1OffsetPercentage(80f);//数据连接线距图形片内部边界的距离，为百分数
        dataSet.setValueLinePart1Length(0.3f);
        dataSet.setValueLinePart2Length(0.4f);
        dataSet.setValueLineColor( PIE_COLORS[3]);//设置连接线的颜色
        dataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);//y轴数据显示在饼图内/外
        dataSet.setXValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);//x轴数据显示在饼图内/外
</code></pre>
<h2 id="webview加载assets文件夹下的html文件">WebView加载assets文件夹下的html文件</h2>
<pre><code class="language-java">webView.loadUrl(&quot;file:////android_asset/文件名.html&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[论【装逼】]]></title>
        <id>https://yangspica27.github.io/post/lun-zhuang-bi</id>
        <link href="https://yangspica27.github.io/post/lun-zhuang-bi">
        </link>
        <updated>2020-02-06T11:26:04.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="/post-images/1581212071153.jpg" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yangspica27.github.io//post-images/1581212071153.jpg" alt="" loading="lazy"></figure>
<!-- more -->
<p>很多行为某个人看不惯，然后就被直接归纳为，或者说...被攻击为「装逼」<br>
是不是在卖弄虚荣这点并不是一个很明确的东西<br>
我写的文字会不会也被某个人看作是单纯的「装逼」呢<br>
其实在现实中倒是经常发生这种事情<br>
但是有时候真的就只是，他们不理解而已<br>
而不是只关心你在讨论的问题或者对话或者事情本身<br>
对于网路上的单纯的文字交流<br>
要判断对方的心情和感受真的不是一件容易的事情<br>
我们的判断其实充满了误解<br>
只要不是面对面都会很难的<br>
比如认真的表情和生气的表情其实不一定能通过一张静态的照片看出来因为他们可能完全一样在那个瞬间<br>
我上初高中的时候，经常被我们班同学以『装逼』的名义攻击。。<br>
后来我上了大学，改变了策略，有意不对我同学露出我在别的方面占优势的地方。。<br>
唉。。<br>
宫崎骏老爷子就会比较直接的说他们都是猪了</p>
]]></content>
    </entry>
</feed>