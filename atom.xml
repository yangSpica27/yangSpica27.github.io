<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yangspica27.github.io/</id>
    <title>Spica 27&apos;S Room</title>
    <updated>2020-02-11T12:29:45.148Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yangspica27.github.io/"/>
    <link rel="self" href="https://yangspica27.github.io/atom.xml"/>
    <subtitle>玻璃晴朗 橘子辉煌</subtitle>
    <logo>https://yangspica27.github.io/images/avatar.png</logo>
    <icon>https://yangspica27.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Spica 27&apos;S Room</rights>
    <entry>
        <title type="html"><![CDATA[进程和线程学习笔记]]></title>
        <id>https://yangspica27.github.io/post/jin-cheng-he-xian-cheng-xue-xi-bi-ji</id>
        <link href="https://yangspica27.github.io/post/jin-cheng-he-xian-cheng-xue-xi-bi-ji">
        </link>
        <updated>2020-02-11T11:16:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进程">进程</h2>
<ul>
<li>给每个程序提供的独立封闭的环境，里面有各种资源和线程</li>
</ul>
<h2 id="区别">区别</h2>
<ul>
<li>同进程下的线程可以共享资源，进程之间无法直接共享资源</li>
</ul>
<h2 id="使用thread类来定义工作">使用Thread类来定义工作</h2>
<pre><code class="language-java">    Thread thread=new Thread(){
      @Override public void run() {
        super.run();
        //工作内容
      }
    };
</code></pre>
<h2 id="使用runable来定义工作">使用Runable来定义工作</h2>
<pre><code class="language-java">    Runnable runnable =
        new Runnable() {
          @Override
          public void run() {

            while (flag) {}
          }
        };
        Thread thread=new Thread(runnable);
</code></pre>
<h2 id="工厂方法">工厂方法</h2>
<pre><code class="language-java"> ThreadFactory threadFactory=new ThreadFactory() {
      int count=1;
      @Override public Thread newThread(@NonNull Runnable r) {
        count++;
        return new Thread(r,count+&quot;&quot;);
      }
    };
    
    Thread thread=threadFactory.newThread(runnable);
</code></pre>
<h2 id="executor">Executor</h2>
<pre><code class="language-java"> Executor executor = Executors.newCachedThreadPool();
    executor.execute(runnable);
</code></pre>
<ul>
<li>newCachedThreadPool()<br>
初始0个线程，可以不断添加，用完后线程会暂时缓存，过段时间之后会回收</li>
<li>newSingleThreadExecutor();<br>
只能跑一个线程，放多个会排队进行</li>
<li>Executors.newFixedThreadPool(5);<br>
只能跑限定个数的线程，需要自己做资源回收<br>
<code>((ExecutorService)executor).shutdown();</code></li>
</ul>
<h2 id="callable-可以看作有返回值的runnable">Callable (可以看作有返回值的Runnable)</h2>
<pre><code class="language-java">Callable&lt;String&gt; callable=new Callable&lt;String&gt;() {
    @Override public String call() throws Exception {
      return &quot;string&quot;;
    }
  };
  ExecutorService executor=Executors.newCachedThreadPool();
  Future&lt;String&gt; future=executor.submit(callable);
  String result=future.get();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP学习笔记2]]></title>
        <id>https://yangspica27.github.io/post/http-xue-xi-bi-ji-2</id>
        <link href="https://yangspica27.github.io/post/http-xue-xi-bi-ji-2">
        </link>
        <updated>2020-02-11T06:58:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="编码加密hash">编码，加密，Hash</h1>
<h2 id="加密">加密</h2>
<ul>
<li>对称加密
<ul>
<li>原理：使用密钥和加密算法对数据进行转换，得到的无意义的数据即为密文。使用密钥和解密算法对密文进行逆向转换，得到原数据。</li>
<li>经典算法：AES DES</li>
</ul>
</li>
<li>非对称加密
<ul>
<li>原理使用公钥对数据进行加密得到密文，使用私钥对数据解密得到原数据</li>
<li>经典算法：RSA DSA</li>
<li>衍生用途：数字签名<br>
原数据---加密算法+加密密钥===&gt;密文---加密算法+解密密钥===&gt;原数据</li>
</ul>
</li>
<li>密钥（key）
<ul>
<li>场景：用于加密和解密</li>
<li>目的：保证数据被人截取时不被人读懂</li>
<li>焦点：数据</li>
</ul>
</li>
<li>密码（pasword）
<ul>
<li>场景：用户进入网站或者游戏的身份验证</li>
<li>目的：数据提供方或者应用服务方对账户拥有者的数据的保护，保证<strong>你是你</strong>的时候提供权限</li>
<li>焦点：身份</li>
</ul>
</li>
</ul>
<h2 id="base64">Base64</h2>
<ul>
<li>将二进制数据转化为64个字符组成的字符串的编码算法</li>
<li>用途：让原数据拥有字符串所拥有的特性，如可以放在URL中传播，可以保存到文本文件，可以通过普通聊天软件进行文本传输。</li>
<li>可以将人眼可读的字符串变为读不懂的字符串，降低窥视危险</li>
</ul>
<h2 id="url-encoding">URL Encoding</h2>
<ul>
<li>将URL中的保留字符使用百分号”%“进行编码（”+“，”/“，&quot;&amp;&quot;等）</li>
<li>消除歧义避免解析错误
<ul>
<li>例: http://spica.com/user/?name=我&amp;你<br>
👇<br>
http://spica.com/user/?name=我&amp;26你</li>
</ul>
</li>
</ul>
<h2 id="压缩和解压缩">压缩和解压缩</h2>
<ul>
<li>
<p>压缩：把数据换一种方式来存储，减少存储空间</p>
</li>
<li>
<p>解压缩：把压缩后的数据还原为原先的形式，以便使用</p>
</li>
<li>
<p>常见压缩算法：DEFLATE,JPEG,MP3</p>
</li>
<li>
<p>压缩属于编码吗？</p>
<ul>
<li>编码五官方定义</li>
<li>压缩属于编码</li>
</ul>
</li>
<li>
<p>媒体数据的编码解码</p>
<ul>
<li>图片的编码：把图像数据写成JPG，PNG，等文件的编码格式</li>
<li>图片的解码：把JPG,PNG等文件的数据解析为标准的图像数据</li>
</ul>
<h2 id="序列化">序列化</h2>
<ul>
<li>把数据对象（一般为内存中的，例如JVM对象）转换为字节序列的过程</li>
<li>目的：让内存中的对象可以被存储和传输</li>
</ul>
<h2 id="hash">Hash</h2>
<ul>
<li>把任意数据转化为指定大小范围（通常很小的计算）</li>
<li>作用:摘要，数字指纹</li>
<li>经典算法：MD5，SHA1，SH256等等</li>
<li>实际用途：数据完整性验证，快速查找：hashCode()和HashMap（）</li>
</ul>
</li>
</ul>
<h2 id="登录和授权">登录和授权</h2>
<ul>
<li>Cookie</li>
<li>Authorization</li>
</ul>
<h2 id="cookie">Cookie</h2>
<ul>
<li>
<p>起源：购物车</p>
</li>
<li>
<p>工作机制：</p>
<ol>
<li>客户端-----&gt;服务器<br>
Post/cart HTTP/1.1<br>
Host：shop.com<br>
Cookie:cart=&quot;apple=1 &quot; banana=1</li>
<li>服务器----&gt;客户端<br>
HTTP/1.1 200 ok<br>
set-Cookie：Cart=”apple=1&amp;banana=1“</li>
<li>客户端<br>
shop.com:<br>
cart:&quot;apple=1&amp;banana=1&quot;</li>
</ol>
</li>
<li>
<p>Cookie的作用：</p>
<ul>
<li>会话管理：购物车，登录状态等等</li>
<li>使用Cookie管理登录状态</li>
<li>个性化</li>
<li>分析用户行为</li>
</ul>
</li>
<li>
<p>Xss(cross-site scrpting):HTTP only 跨站脚本攻击</p>
<ul>
<li>Set-Cookie：Sessionid=123；Http Only 使Cookie对本地脚本不可见</li>
</ul>
</li>
<li>
<p>XSRF（cross-site request forgery ）：Referer：跨站请求伪造<br>
利用之前登录留下的Cookie实现无登录转账</p>
</li>
</ul>
<h2 id="authorization">Authorization</h2>
<ul>
<li>Authorization: Basic<code>&lt;Username：passwor(base64)&gt;</code></li>
<li>Authorization: Bearer<code>&lt;bearer token&gt;</code>
<ul>
<li>OAuth2</li>
<li>微信登录</li>
</ul>
</li>
</ul>
<h2 id="tcpip协议簇">TCP/IP协议簇</h2>
<ul>
<li>一系列模型组成的网络模型分层</li>
<li>为什么要分层：因为网络不稳定</li>
<li>具体分层：
<ul>
<li>应用层：HTTP，FTP，DNS</li>
<li>传输层：TCP，UDP</li>
<li>网络层：IP</li>
<li>数据链路层：以太网，WIFI</li>
</ul>
</li>
<li>TCP连接
<ul>
<li>三次握手...</li>
</ul>
</li>
<li>长连接：
<ul>
<li>实现方式：心跳<br>
在类小区网络环境下，防止长时间不连接端口关闭</li>
</ul>
</li>
</ul>
<h1 id="https">HTTPS</h1>
<ul>
<li>HTTP OVER SSL</li>
<li>SSL：Secure Socket Layer====&gt;TLS：Transport Layer Secure</li>
<li>定义：在HTTP下增加一个安全层，用于保障HTTP的加密传输</li>
<li>本质：在客户端和服务器之间协商出一套对称密钥，每次发送信息之间将内容加密，收到之后在进行解密，达到内容加密传输</li>
</ul>
<h2 id="http-连接">HTTP 连接</h2>
<ol>
<li>客户端请求建立TLS连接</li>
<li>服务器发回证明</li>
<li>客户端验证服务器证书</li>
<li>客户端信任服务器之后，和服务器协商对称密钥</li>
<li>使用对称密钥开始通信</li>
</ol>
<h1 id="在android中使用">在Android中使用</h1>
<ul>
<li>正常情况下，直接使用</li>
<li>什么时候不行：
<ul>
<li>用的自签名证书（例如用于内网的Https）</li>
<li>证书信息补全，缺乏证书机构信息</li>
<li>手机操作系统较旧，没有安装新加入的根证书</li>
</ul>
</li>
<li>如何处理：
<ul>
<li>手写验证过程</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 学习笔记1]]></title>
        <id>https://yangspica27.github.io/post/http-xue-xi-bi-ji</id>
        <link href="https://yangspica27.github.io/post/http-xue-xi-bi-ji">
        </link>
        <updated>2020-02-11T05:27:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http">HTTP</h1>
<ul>
<li>HyperText Transfer Portocol 超文本传输协议
<ul>
<li>超文本：在电脑中，显示的含有可以指向其他文本链接的文本</li>
</ul>
</li>
</ul>
<h2 id="http的工作方式">HTTP的工作方式</h2>
<ul>
<li>
<p><strong>浏览器</strong>--&gt;发送请求--&gt;<strong>服务器</strong><br>
GET/HTTP/1.1<br>
Host：····.com</p>
</li>
<li>
<p><strong>服务器</strong>--&gt;响应--&gt;<strong>浏览器</strong><br>
HTTP/1.1 200 OK<br>
Server：nginx/1.13.1<br>
Date：Sun，0，...</p>
</li>
</ul>
<h2 id="url-http报文">URL---&gt;HTTP报文</h2>
<ul>
<li>示例：http://space.bilibili.comsp/56285643<br>
<strong>https:</strong> 协议类型<br>
<strong>space.bilibili.com</strong>：服务器地址<br>
<strong>56285643：</strong> 路径<br>
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</li>
<li>GET/56285643 HTTP/1.1<br>
Host:space.bilibili.comsp</li>
</ul>
<ul>
<li>报文格式：Request<pre><code>  GET/Users HTTP？1.1 //请求行
  Host:api.githu.com                 //headers    
  Content-Type: text/plain           //headers    
  Content-Length:243                //headers   
  ...                                       //body
</code></pre>
</li>
<li>报文格式：Response</li>
</ul>
<pre><code>HTTP/1.1 200 OK //状态行
//请求头
Content-type：application/json；charset=UTF-8 //headers
Cache-control：public，max-age=60，S-maxage=60
vary：Accept，Accept-Encoding
etag：w/“02eec5b33460”
Content-encoding:g-zip
//Body
[{
    .......
}]
</code></pre>
<h2 id="request-methods">Request Methods</h2>
<ul>
<li><strong>Get</strong><br>
获取资源，无Body</li>
<li>Post<br>
增加或者修改资源；Body</li>
<li><strong>Put</strong><br>
修改资源；有Body</li>
<li><strong>DELETE</strong><br>
删除资源；无Body</li>
<li>HEAD<br>
获取信息；如下载文件的大小；服务器不返回Body<br>
<strong>Get/Put/DELETE具有幂等性</strong></li>
</ul>
<h2 id="status-code-状态码">Status Code 状态码</h2>
<ul>
<li>1xx: 临时性消息<br>
101：支持HTTP2.0<br>
100：未完成</li>
<li>2XX：成功</li>
<li>3XX：重定向<br>
301：永久迁移<br>
302：临时迁移<br>
304：内容无改变</li>
<li>4XX：客户端错误</li>
<li>5XX：服务器错误</li>
</ul>
<h2 id="header-请求头">Header 请求头</h2>
<ul>
<li>
<p>作用：HTTP消息的<strong>元数据</strong>（metadata）</p>
<ul>
<li>Host:服务器的主机地址   虚拟主机</li>
<li>Content-Type/Content-Length： Body的类型/长度
<ul>
<li>Content-Length：内容的长度(字节)</li>
<li>Content-Type：
<ul>
<li>text/html：HTML内容，用于浏览器页面响应</li>
<li>application/x-www-form-urlencoded：普通表单</li>
<li>encoded：URL模式</li>
</ul>
</li>
</ul>
</li>
<li>multipart/form-data：多部分形式；包含二进制的多内容</li>
<li>application/json：json形式，用于Web Api的响应或者Post/Put请求</li>
<li>image/jpeg/application/zip...：单文件，用于Web API响应或者put/post请求</li>
</ul>
<h2 id="chunked-transfer-encoding">Chunked Transfer Encoding</h2>
</li>
</ul>
<ul>
<li>Transfer-Encoding：chunked<br>
表示Body长度无法确定，Content-Length不能使用<br>
Body格式：<pre><code class="language-XML">&lt;length&gt;
&lt;data1&gt;
&lt;length2&gt;
&lt;date2&gt;
......
0

</code></pre>
</li>
</ul>
<p><strong>0加换行</strong></p>
<p>最后传输0表示内容结束</p>
<ul>
<li>Location:重定向的目标URL</li>
<li>User-Agent:用户代理</li>
<li>Range/Accept-Range：指定Body内容范围</li>
<li>Cookie/Set-Cookie：发送/设置 Cookie</li>
<li>Authorization:授权信息</li>
<li>Accept：客户端可接受的数据类型：如text/html</li>
<li>Accept-charset：客户端接收的字符集：如 UTF-8</li>
<li>Accept-Encoding：客户端接收的压缩类型编码。如gzip</li>
<li>Conetent-Encoding：压缩类型：如gzip</li>
</ul>
<h2 id="cache-缓存">Cache 缓存</h2>
<ul>
<li>Cache和Butter的区别？</li>
<li>Cache-Control：
<ul>
<li>no-cache： 缓存，使用前询问</li>
<li>no-store：不缓存</li>
<li>max-age：指定日期</li>
</ul>
</li>
<li>Last-Modified：
<ul>
<li>If-Modified-since</li>
</ul>
</li>
<li>ETag：  If-None-Match</li>
<li>Cache-Control：private/public  个性信息/公共信息</li>
</ul>
<p>##REST</p>
<ul>
<li>什么是<strong>REST</strong>：<br>
一种架构风格对HTTP加以限制</li>
<li>Sever-Client architecture     CS架构</li>
<li>StateLessness     无状态</li>
<li>Cacheablility     可缓存</li>
<li>Layered System 分层的服务器集群对客户端透明</li>
<li>Code on demand 服务器返回包含可执行代码</li>
<li>Uniform interface
<ul>
<li>Resource identication in requests</li>
<li>Resource manipulation through representation</li>
<li>self-descriptive messages</li>
<li>Hypermedia as engine of application state（HATEOAS）</li>
</ul>
</li>
</ul>
<h2 id="restful-http">RESTFUL HTTP</h2>
<ul>
<li>正确的使用Http</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何自定义一个简单的自动换行的TagLayout布局]]></title>
        <id>https://yangspica27.github.io/post/ru-he-zi-ding-yi-yi-ge-jian-dan-de-zi-dong-huan-xing-de-taglayout-bu-ju</id>
        <link href="https://yangspica27.github.io/post/ru-he-zi-ding-yi-yi-ge-jian-dan-de-zi-dong-huan-xing-de-taglayout-bu-ju">
        </link>
        <updated>2020-02-10T13:21:11.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yangspica27.github.io//post-images/1581341006296.png" alt="" loading="lazy"></figure>
<h1 id="先上完整代码">先上完整代码：</h1>
<pre><code class="language-java">public class TagLayout extends ViewGroup {

  List&lt;Rect&gt; childrenBounds = new ArrayList&lt;&gt;();

  public TagLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
  }

  @Override
  protected void onLayout(boolean changed, int l, int t, int r, int b) {
    for (int i = 0; i &lt; getChildCount(); i++) {
      View child = getChildAt(i);
      Rect childBound = childrenBounds.get(i);
      child.layout(childBound.left, childBound.top, childBound.right, childBound.bottom);
    }
  }

  @Override
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    int lineMaxWidth = 0;
    int heightUse = 0;
    int widthUse = 0;
    int lineMaxHeight = 0;

    int specMode=MeasureSpec.getMode(widthMeasureSpec);

    int specWidth = MeasureSpec.getSize(widthMeasureSpec);

    for (int i = 0; i &lt; getChildCount(); i++) {
      View child = getChildAt(i);

      measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, heightUse);

      if (specMode!=MeasureSpec.UNSPECIFIED&amp;&amp;widthUse + child.getMeasuredWidth() &gt; specWidth) {
        // 另起一行
        widthUse = 0;
        heightUse += lineMaxHeight;
        lineMaxHeight=0;
        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, heightUse);
      }

      Rect childBound;
      if (childrenBounds.size() &lt;= i) {
        childBound = new Rect();
        childrenBounds.add(childBound);
      } else {
        childBound = childrenBounds.get(i);
      }

      childBound.set(
          widthUse,
          heightUse,
          widthUse + getMeasuredWidth(),
          heightUse + getMeasuredHeight());

      widthUse += child.getMeasuredWidth();
      lineMaxWidth = Math.max(lineMaxWidth, widthUse);
      lineMaxHeight = Math.max(lineMaxHeight, child.getMeasuredHeight());
    }

    int width = lineMaxWidth;
    int height = lineMaxHeight+heightUse;
    setMeasuredDimension(width, height);
  }

  @Override
  public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new MarginLayoutParams(getContext(), attrs);
  }
}

## 准备工作
定义一个容器来存储子View的位置信息：
```java
  List&lt;Rect&gt; childrenBounds = new ArrayList&lt;&gt;();
</code></pre>
<h2 id="先从onmeasure阶段开始">先从onMeasure（）阶段开始</h2>
<h3 id="定义了四个量">定义了四个量：</h3>
<pre><code class="language-java">    int widthUse = 0;//使用了多少宽度
    int heightUse = 0;//使用了多少高度
    int lineMaxWidth = 0; //当前最大宽度
    int lineMaxHeight = 0;//当前最大高度
</code></pre>
<p>这个布局是个横向排列的过程，我们用一个<code>widthUse</code>来记录当前行横向使用的宽度，则计算下个子View位置时候，只需在此基础上累加即可。<br>
而<code>lineMaxHeight</code>用来记录当前行的子View中的最大高度，当换行时候传递给<code>heightUse</code>，使下一阶段的子View添加下沉高度。</p>
<h3 id="这段代码是什么意义">这段代码是什么意义：</h3>
<pre><code class="language-java">   measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, heightUse);
</code></pre>
<p>这其实是安卓帮我们做了一个自动计算的过程：</p>
<pre><code class="language-java">    LayoutParams layoutParams = child.getLayoutParams();

      int specWidthMode = MeasureSpec.getMode(widthMeasureSpec);
      int specWidthSize = MeasureSpec.getSize(widthMeasureSpec);

      int childWidthMode;
      int childWidthSize;

      switch (layoutParams.width) {
        case LayoutParams.MATCH_PARENT:
          switch (specWidthMode) {
            case MeasureSpec.EXACTLY:
            case MeasureSpec.AT_MOST:
              childWidthMode = MeasureSpec.EXACTLY;
              childWidthSize = specWidthSize - useWidth;
              break;
            case MeasureSpec.UNSPECIFIED:
              childWidthMode = MeasureSpec.UNSPECIFIED;
              childWidthSize = 0;
              break;
          }
          break;
        case LayoutParams.WRAP_CONTENT:
          break;
      }
</code></pre>
<p>可以类比为如上的代码，根据开发者传入的参数类型进行数值的自动适配</p>
<h2 id="onlayout阶段">onLayout()阶段</h2>
<p>循环设置布局参数</p>
<pre><code class="language-java">    for (int i = 0; i &lt; getChildCount(); i++) {
      View child = getChildAt(i);
      Rect childBound = childrenBounds.get(i);
      child.layout(childBound.left, childBound.top, childBound.right, childBound.bottom);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ resolveSize()的使用]]></title>
        <id>https://yangspica27.github.io/post/resolvesizede-shi-yong</id>
        <link href="https://yangspica27.github.io/post/resolvesizede-shi-yong">
        </link>
        <updated>2020-02-10T11:45:59.000Z</updated>
        <content type="html"><![CDATA[<p>绘制自定义View的时候，<code>onMeasure</code>阶段需要根据类型来决定宽高（外部自定义或者有最大宽高），由此需要对内部参数进行改变，所以常常要写这种代码：</p>
<pre><code class="language-java"> switch (specMode) {
            case MeasureSpec.AT_MOST:
        //.....
                break;
            case MeasureSpec.EXACTLY:
      //....
            case MeasureSpec.UNSPECIFIED:
 }
</code></pre>
<p>但Android已经进行了封装，我们只需要调用<code>resolveSize(内部设定的数值，Measure的原始值)</code>就可以自动为我们选择合适的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[View的测量]]></title>
        <id>https://yangspica27.github.io/post/view-de-ce-liang</id>
        <link href="https://yangspica27.github.io/post/view-de-ce-liang">
        </link>
        <updated>2020-02-10T09:51:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="从整体看">从整体看</h3>
<ul>
<li>测量流程：从根View递归调用每一级子View的<code>measure( )</code>方法，对他们进行测量</li>
<li>布局流程：从根View递归调用每一级子View的<code>layout（ )</code>方法，把测量过程得出子View的位置和尺寸传给子View，子View保存</li>
</ul>
<h3 id="从个体看对于每个view">从个体看，对于每个View</h3>
<ol>
<li>运行前，开发者在xml文件里写入对View的布局要求layout_xxx</li>
<li>父View在自己的<code>onMeasure( )</code>中，根据开发者在xml中写的对子View的要求，和自己的可用空间，得出对子View的具体尺寸要求。</li>
<li>子View在自己的<code>onMeasure( )</code>中根据自己的特性算出自身的期望尺寸
<ul>
<li>如果是ViewGroup，还会在这里调用每个子View的<code>measure( )</code>进行测量</li>
</ul>
</li>
<li>父View在子View计算出期望尺寸后，得出子View的实际尺寸和位置</li>
<li>子View在自己的<code>layout( )</code>方法中，将父View传进来的自己的实际尺寸和位置保存<br>
-如果是ViewGroup，还会在<code>onLayout( )</code>里调用每个字View的<code>layout( )</code>把他们尺寸位置给他们</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[活出自己]]></title>
        <id>https://yangspica27.github.io/post/huo-chu-zi-ji</id>
        <link href="https://yangspica27.github.io/post/huo-chu-zi-ji">
        </link>
        <updated>2020-02-10T00:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>今天有人来问我，说如何成为像我这样的人。<br>
　　让我受宠若惊。<br>
　　我一时脑子短路不知道说什么好，就心血来潮回了一句：“不可能”<br>
　　像，也只是像而已。<br>
　　像是那些拙劣的iPhone模仿者一样，他们再吹嘘自己在某某部分上远超iPhone，但他们终究没有能够超越iPhone。<br>
　　他们终究选择了做自己。不论好坏。<br>
　　也或许有一部分执迷不悟，而已经退出了这个游戏。<br>
　　能生存下来的也终究不是靠模仿iPhone.<br>
　　人似乎也是如此。<br>
　　如果我可以有一个双胞胎兄弟。小时候我们穿着一样的衣服，做着一样的事情，一起开心，一起哭泣。<br>
　　可是长大以后，也会发现他和我并不相同。我也没有必要和他相同。<br>
　　世界可以说很大，也可以很小。<br>
　　把这个世界上所有人堆在一起，缩小了看，它们都属于Homo Sapian.<br>
　　放大了看，其实每个人都站在不同的点上。即使有再小的不同，我们终究也还是不同的。<br>
　　我们曾经想成为科学家，成为歌手，成为画家，成为音乐家。<br>
　　上了学，我们想成为班上那最顶端的学生。<br>
　　现在我终于可以说，<br>
　　“我想成为谁啊？是我自己啊。”<br>
　　我不再仰望Bill Gates的退学勇气，也不用羡慕Steve的现实扭曲立场，不必在意Jay Chou的歌究竟有多么吐字不清，不用再纠结我前方的几千人到底是怎么考出这个成绩的。<br>
　　评估这个世界的轴已经从单一的成了多元的了。<br>
　　而在我的世界里，总有比他们走的远的一个方向。<br>
　　而没有超过他们的，自然没有必要担心。<br>
　　我就是我啊。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何绘制一个MD风格的输入框]]></title>
        <id>https://yangspica27.github.io/post/ru-he-hui-zhi-yi-ge-md-feng-ge-de-shu-ru-kuang</id>
        <link href="https://yangspica27.github.io/post/ru-he-hui-zhi-yi-ge-md-feng-ge-de-shu-ru-kuang">
        </link>
        <updated>2020-02-09T13:18:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://yangspica27.github.io//post-images/1581254342503.gif" alt="" loading="lazy"></figure>
<h2 id="提要">提要</h2>
<p>首先我们分析效果图 达成的效果 输入框有数值的时候，绘制hint的文字在顶部，当输入框没有数值的时候将绘制的文字去掉，并且过程中插入一个向下/向上的一个移动动画。</p>
<h2 id="准备工作">准备工作</h2>
<p>首先定义需要的量</p>
<pre><code class="language-java">public static final float TEXT_SIZE = Utils.dpTopx(12);//绘制的hint的文字大小
public static final float TEXT_MARGIN = Utils.dpTopx(8);//绘制的hint文本的缩进距离
public static final int TEXT_VERTICAL_OFFSET = (int) Utils.dpTopx(22);//绘制的hint文字水平偏移
public static final int TEXT_HORIZONTAL_OFFSET = (int) Utils.dpTopx(5);//绘制的hint文字垂直方向偏移
public static final int TEXT_ANIMATION_OFFSET = (int) Utils.dpTopx(16);//动画的移动幅度
boolean floatingLableShow;//当前状态：是否显示上部的hint文字

Rect boundPading;//用于获取pading
float floatingLableFraction = 0;//动画执行的进度
private boolean useFloatingLabel = true;//是否使用MD效果
ObjectAnimator animator;//动画对象
Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);//绘制文字的画笔
</code></pre>
<h2 id="初始化">初始化</h2>
<pre><code class="language-java">{
      paint.setTextSize(TEXT_SIZE);
}
public MaterialEditText(Context context, AttributeSet attrs) {
    super(context, attrs);
    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MaterialEditText);
    useFloatingLabel = typedArray.getBoolean(R.styleable.MaterialEditText_useFloatingLabel, true);//获取attr中声明的值，如果不需要在xml中设置属性，可以跳过此步骤
    typedArray.recycle(); // 回收
  }
</code></pre>
<h2 id="hint文字的绘制">Hint文字的绘制</h2>
<pre><code class="language-java">  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    paint.setAlpha((int) (0xff * floatingLableFraction));//根据动画执行的进度设置画笔的透明度
    float extraOffset = TEXT_ANIMATION_OFFSET * (1 - floatingLableFraction);//根据动画的执行进度获取水平方向上的偏移量

    if (useFloatingLabel) {
      canvas.drawText(
          (String) getHint(), TEXT_HORIZONTAL_OFFSET, TEXT_VERTICAL_OFFSET + extraOffset, paint);//绘制文字，绘制时候根据动画进度可以变化水平位置
    }
  }
</code></pre>
<h2 id="动画">动画</h2>
<pre><code class="language-java">private ObjectAnimator getAninator() {
    if (animator == null) {
      animator = ObjectAnimator.ofFloat(MaterialEditText.this, &quot;floatingLableFraction&quot;, 0, 1);
    }
    return animator;
  }
</code></pre>
<h2 id="布局重新测量">布局重新测量</h2>
<pre><code class="language-java">private void onUseFloatLableChanged() {

    if (useFloatingLabel) {
      setPadding(
          getPaddingLeft(),
          (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),//显示的时候，将布局向上排
          getPaddingRight(),
          getPaddingBottom());

    } else {
      setPadding(getPaddingLeft(), (boundPading.top), getPaddingRight(), getPaddingBottom());//不使用时候则将padding恢复原始状态
    }
  }
</code></pre>
<pre><code class="language-java">  public void setUseFloatingLabel(boolean useFloatingLabel) {

    if (this.useFloatingLabel != useFloatingLabel) {
      this.useFloatingLabel = useFloatingLabel;//当状态改变时候
      onUseFloatLableChanged();//应用变化
    }
    requestLayout(); // 重新测量
  }
</code></pre>
<h2 id="设置监听器">设置监听器</h2>
<pre><code class="language-java"> addTextChangedListener(
        new TextWatcher() {
          @Override
          public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

          @Override
          public void onTextChanged(CharSequence s, int start, int before, int count) {

            if (useFloatingLabel) {

              if (floatingLableShow &amp;&amp; TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().reverse();//逆向执行动画

              } else if (!floatingLableShow &amp;&amp; !TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().start();
              }
            }
          }

          @Override
          public void afterTextChanged(Editable s) {}
        });
</code></pre>
<h1 id="tips">Tips</h1>
<ul>
<li>
<p>为什么获取paddingTop使用<code>boundPading.top</code>而不会使用<code>getPaddingTop</code>?<br>
因为此View中，Padding并不是一个定值，每次<code>setPadding</code>的时候，都会进行改变,所以要将Padding恢复的时候，要涉及到一个累减的一个问题，而从background中获取的bounds是一个定值，所以可以有效避免复杂的计算。</p>
</li>
<li>
<p><code>getAninator().start();</code>和<code>getAninator().reverse();</code>啥玩意还能这样子操作？？？<br>
使用<code>getAninator()</code>可以避免重复构造动画对象避免性能损失，start表示的是动画的正方向执行，reverse表示倒叙执行</p>
</li>
</ul>
<h3 id="完整代码">完整代码</h3>
<pre><code class="language-java">public class MaterialEditText extends AppCompatEditText {
  private static final String TAG = &quot;MaterialEditText&quot;;

  public static final float TEXT_SIZE = Utils.dpTopx(12);

  public static final float TEXT_MARGIN = Utils.dpTopx(8);
  public static final int TEXT_VERTICAL_OFFSET = (int) Utils.dpTopx(22);
  public static final int TEXT_HORIZONTAL_OFFSET = (int) Utils.dpTopx(5);
  public static final int TEXT_ANIMATION_OFFSET = (int) Utils.dpTopx(16);

  Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);

  boolean floatingLableShow;

  ObjectAnimator animator;

  Rect boundPading;
  float floatingLableFraction = 0;
  private boolean useFloatingLabel = true;

  {
    paint.setTextSize(TEXT_SIZE);
    boundPading = getBackground().getBounds();

    setPadding(
        getPaddingLeft(),
        (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),
        getPaddingRight(),
        getPaddingBottom());

    addTextChangedListener(
        new TextWatcher() {
          @Override
          public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

          @Override
          public void onTextChanged(CharSequence s, int start, int before, int count) {

            if (useFloatingLabel) {

              if (floatingLableShow &amp;&amp; TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().reverse();

              } else if (!floatingLableShow &amp;&amp; !TextUtils.isEmpty(s)) {
                floatingLableShow = !floatingLableShow;
                getAninator().start();
              }
            }
          }

          @Override
          public void afterTextChanged(Editable s) {}
        });
  }

  public MaterialEditText(Context context, AttributeSet attrs) {
    super(context, attrs);
    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MaterialEditText);
    useFloatingLabel = typedArray.getBoolean(R.styleable.MaterialEditText_useFloatingLabel, true);
    typedArray.recycle(); // 回收
  }

  public float getFloatingLableFraction() {
    return floatingLableFraction;
  }

  public void setFloatingLableFraction(float floatingLableFraction) {
    this.floatingLableFraction = floatingLableFraction;
    invalidate();
  }

  private void onUseFloatLableChanged() {

    if (useFloatingLabel) {
      setPadding(
          getPaddingLeft(),
          (int) (boundPading.top + TEXT_SIZE + TEXT_MARGIN),
          getPaddingRight(),
          getPaddingBottom());

    } else {
      setPadding(getPaddingLeft(), (boundPading.top), getPaddingRight(), getPaddingBottom());
    }
  }

  public void setUseFloatingLabel(boolean useFloatingLabel) {

    if (this.useFloatingLabel != useFloatingLabel) {
      this.useFloatingLabel = useFloatingLabel;
      onUseFloatLableChanged();
    }
    requestLayout(); // 重新测量
  }

  private ObjectAnimator getAninator() {
    if (animator == null) {
      animator = ObjectAnimator.ofFloat(MaterialEditText.this, &quot;floatingLableFraction&quot;, 0, 1);
    }
    return animator;
  }

  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    paint.setAlpha((int) (0xff * floatingLableFraction));
    float extraOffset = TEXT_ANIMATION_OFFSET * (1 - floatingLableFraction);

    if (useFloatingLabel) {
      canvas.drawText(
          (String) getHint(), TEXT_HORIZONTAL_OFFSET, TEXT_VERTICAL_OFFSET + extraOffset, paint);
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[随想]]></title>
        <id>https://yangspica27.github.io/post/sui-xiang</id>
        <link href="https://yangspica27.github.io/post/sui-xiang">
        </link>
        <updated>2020-02-09T01:36:49.000Z</updated>
        <content type="html"><![CDATA[<p>作为程序员，如果一个问题出现第二次，就是不能容忍的，但生活中，每个人都难以避免地不断重新犯错，过去的我总觉得给别人三次机会就不能再多了，这很多时候导致了我的不开心，直到我发觉这个事情，并不是每个人都是程序员，特别是家人，很多事情的宽容次数，三次不够，设为十次也不应该，如果可以，应该尽可能无限次宽容，因为他们也总是无限次宽容你，推广开来，就算是对外人也应该如此，宽容没有限数，不要再有后悔莫及的事情了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[技能大赛训练知识小点]]></title>
        <id>https://yangspica27.github.io/post/Competition_notes</id>
        <link href="https://yangspica27.github.io/post/Competition_notes">
        </link>
        <updated>2020-02-09T01:03:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断网络状态">判断网络状态</h2>
<pre><code class="language-java">private boolean testIntent() {
  ConnectivityManager mConnectivityManagerr =
      (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo mNetworkInfo = mConnectivityManagerr.getActiveNetworkInfo();
  if (mNetworkInfo != null) {
    return mNetworkInfo.isAvailable();
  }
  return false;
}
</code></pre>
<h2 id="地图初始化">地图初始化</h2>
<pre><code class="language-java">//地图的初始化：
@Override
protected void onDestroy() {
  super.onDestroy();
  mMapView.onDestroy();
}
@Override
protected void onResume() {
  super.onResume();
  mMapView.onResume();
}
@Override
protected void onPause() {
  super.onPause();
  mMapView.onPause();
}
@Override
protected void onSaveInstanceState(Bundle outState) {
  super.onSaveInstanceState(outState);
  mMapView.onSaveInstanceState(outState);
}
</code></pre>
<h2 id="地图切换图层">地图切换图层</h2>
<pre><code class="language-java">aMap.setMapType(AMap.MAP_TYPE_SATELLITE);
</code></pre>
<h2 id="地图添加点">地图添加点</h2>
<pre><code class="language-java">aMap.addMarker(new MarkerOptions().position(latLngs).title(&quot;小车位置&quot;));
</code></pre>
<h2 id="通知的创建">通知的创建</h2>
<pre><code class="language-java">NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
  NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
builder.setSmallIcon(R.mipmap.icon101);//必须
builder.setContentTitle(“……”);
mNotifyMgr.notify(1, builder.build());
</code></pre>
<h2 id="viewpager预加载">viewPager预加载</h2>
<pre><code class="language-java">viewPager.setOffscreenPageLimit();
</code></pre>
<h2 id="textview跑马灯">TextView跑马灯</h2>
<pre><code class="language-XML">&lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:ellipsize=&quot;marquee&quot;
            android:marqueeRepeatLimit=&quot;marquee_forever&quot; /&gt;
</code></pre>
<pre><code class="language-java">textView.setSelected(true);
</code></pre>
<h2 id="greendao初始化">GreenDao初始化</h2>
<pre><code class="language-java">greendao {
     schemaVersion 1
     daoPackage 'com.lenovo.smarttraffic.db'
     targetGenDir 'src/main/java'
}
    /**
     * 初始化GreenDao,直接在Application中进行初始化操作
     */
    private void initGreenDao() {
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;jiaotong.db&quot;);
        SQLiteDatabase db = helper.getWritableDatabase();
        DaoMaster daoMaster = new DaoMaster(db);
        daoSession = daoMaster.newSession();
    }

    private DaoSession daoSession;
    public DaoSession getDaoSession() {
        return daoSession;
    }
</code></pre>
<h2 id="dp2px无需上下文">dp2px（无需上下文）</h2>
<pre><code class="language-java">public static float dpTopx(int dp) {

  return TypedValue.applyDimension(
      TypedValue.COMPLEX_UNIT_DIP, dp, Resources.getSystem().getDisplayMetrics());
}
</code></pre>
<h2 id="饼图拉线">饼图拉线</h2>
<pre><code class="language-java">dataSet.setValueLinePart1OffsetPercentage(80f);//数据连接线距图形片内部边界的距离，为百分数
        dataSet.setValueLinePart1Length(0.3f);
        dataSet.setValueLinePart2Length(0.4f);
        dataSet.setValueLineColor( PIE_COLORS[3]);//设置连接线的颜色
        dataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);//y轴数据显示在饼图内/外
        dataSet.setXValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);//x轴数据显示在饼图内/外
</code></pre>
<h2 id="webview加载assets文件夹下的html文件">WebView加载assets文件夹下的html文件</h2>
<pre><code class="language-java">webView.loadUrl(&quot;file:////android_asset/文件名.html&quot;);
</code></pre>
]]></content>
    </entry>
</feed>